{"version":3,"sources":["../src/core/types/error.ts","../src/core/transport/ndjson.ts","../src/core/transport/sse.ts","../src/core/transport/websocket.ts","../src/core/transport/factory.ts","../src/core/stream/createStream.ts"],"names":["buildUrl"],"mappings":"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","file":"index.js","sourcesContent":["import type { RTSKStatus } from \"./status\";\n\n/**\n * Discriminated union of error categories surfaced by the SDK.\n *\n * @public\n */\nexport type RTSKErrorKind =\n  | \"transport\"\n  | \"hydrate\"\n  | \"protocol\"\n  | \"internal\";\n\n/**\n * Structured data used to construct {@link RTSKError} instances.\n *\n * @public\n */\nexport interface RTSKErrorDetails {\n  /** Classification of the error. */\n  kind: RTSKErrorKind;\n  /** Human-readable description of what went wrong. */\n  message: string;\n  /** Optional underlying error or diagnostic payload. */\n  cause?: unknown;\n  /** Controller status immediately prior to the error (when known). */\n  statusBefore?: RTSKStatus;\n}\n\n/**\n * Custom error class used throughout the RTSK streaming toolkit.\n *\n * @remarks\n * Instances carry structured context such as error kind and the previous\n * controller status, enabling downstream handling and telemetry.\n *\n * @public\n */\nexport class RTSKError extends Error {\n  /** Classification of the error. */\n  public readonly kind: RTSKErrorKind;\n  /** Optional underlying error or diagnostic payload. */\n  public readonly cause?: unknown;\n  /** Controller status immediately prior to the error (when known). */\n  public readonly statusBefore?: RTSKStatus;\n\n  constructor(details: RTSKErrorDetails) {\n    super(details.message);\n    this.name = \"RTSKError\";\n    this.kind = details.kind;\n    this.cause = details.cause;\n    this.statusBefore = details.statusBefore;\n  }\n}\n","import { RTSKError } from \"../types\";\nimport type {\n    Transport,\n    TransportHandlers,\n    TransportConnectOptions,\n} from \"../types\";\n\n/**\n * Runtime configuration for the NDJSON transport.\n *\n * @public\n */\nexport type NdjsonTransportConfig = {\n    /** Endpoint that exposes an NDJSON stream. */\n    endpoint: string;\n    /** HTTP headers sent with the request when applicable. */\n    headers?: Record<string, string>;\n    /** Query string parameters appended to the endpoint URL. */\n    query?: Record<string, string | number | boolean | null | undefined>;\n    /**\n     * Optional client-side timeout used to abort the request if no response is\n     * received within the allotted milliseconds.\n     */\n    timeoutMs?: number;\n};\n\nfunction buildUrl(endpoint: string, query?: NdjsonTransportConfig[\"query\"]): string {\n    if (!query || Object.keys(query).length === 0) {\n        return endpoint;\n    }\n\n    const url = new URL(endpoint, window.location.origin);\n    Object.entries(query).forEach(([key, value]) => {\n        if (value === undefined || value === null) {\n            return;\n        }\n        url.searchParams.set(key, String(value));\n    });\n\n    return url.toString();\n}\n\n/**\n * Low-level NDJSON transport implementation.\n *\n * @remarks\n * This is an advanced API.\n * Most consumers should prefer {@link createStream}, which provides\n * a higher-level, protocol-agnostic interface with lifecycle management.\n *\n * This transport is exposed for advanced use cases such as custom\n * wiring, testing, or direct transport control.\n *\n * @public\n */\n\nexport class NdjsonTransport<TRaw = unknown> implements Transport<TRaw> {\n    private readonly config: NdjsonTransportConfig;\n    private abortController: AbortController | null = null;\n    private active = false;\n\n    constructor(config: NdjsonTransportConfig) {\n        this.config = config;\n    }\n\n    connect(\n        handlers: TransportHandlers<TRaw>,\n        options?: TransportConnectOptions\n    ): void {\n        if (this.active) {\n            return;\n        }\n\n        this.active = true;\n        this.abortController = new AbortController();\n\n        const signal = this.abortController.signal;\n        const url = buildUrl(this.config.endpoint, this.config.query);\n\n        const payload = options?.payload ?? null;\n\n        const method = payload != null ? \"POST\" : \"GET\";\n\n        const headers: Record<string, string> = {\n            ...(payload != null ? { \"Content-Type\": \"application/json\" } : {}),\n            ...(this.config.headers ?? {}),\n        };\n\n        const fetchOptions: RequestInit = {\n            method,\n            headers,\n            body: payload != null ? JSON.stringify(payload) : undefined,\n            signal,\n        };\n\n        let timeoutId: number | undefined;\n\n        if (this.config.timeoutMs && this.config.timeoutMs > 0) {\n            timeoutId = window.setTimeout(() => {\n                if (this.abortController) {\n                    this.abortController.abort();\n                }\n            }, this.config.timeoutMs);\n        }\n\n        void (async () => {\n            try {\n                const response = await fetch(url, fetchOptions);\n\n                if (!response.ok) {\n                    throw new RTSKError({\n                        kind: \"transport\",\n                        message: `NDJSON fetch failed with status ${response.status}`,\n                        statusBefore: \"connecting\",\n                    });\n                }\n\n                if (!response.body) {\n                    throw new RTSKError({\n                        kind: \"transport\",\n                        message: \"NDJSON response has no body\",\n                        statusBefore: \"connecting\",\n                    });\n                }\n\n                const reader = response.body.getReader();\n                const decoder = new TextDecoder();\n                let buffer = \"\";\n\n                for (;;) {\n                    const { value, done } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n\n                    if (!value) {\n                        continue;\n                    }\n\n                    buffer += decoder.decode(value, { stream: true });\n                    const lines = buffer.split(/\\r?\\n/);\n                    buffer = lines.pop() ?? \"\";\n\n                    for (const line of lines) {\n                        const trimmed = line.trim();\n                        if (!trimmed) {\n                            continue;\n                        }\n\n                        try {\n                            const parsed = JSON.parse(trimmed) as TRaw;\n                            handlers.onRaw(parsed);\n                        } catch (e) {\n                            handlers.onError(\n                                new RTSKError({\n                                    kind: \"protocol\",\n                                    message: \"Invalid NDJSON line\",\n                                    cause: e,\n                                })\n                            );\n                        }\n                    }\n                }\n\n                const last = buffer.trim();\n                if (last) {\n                    try {\n                        const parsed = JSON.parse(last) as TRaw;\n                        handlers.onRaw(parsed);\n                    } catch (e) {\n                        handlers.onError(\n                            new RTSKError({\n                                kind: \"protocol\",\n                                message: \"Invalid trailing NDJSON line\",\n                                cause: e,\n                            })\n                        );\n                    }\n                }\n\n                handlers.onComplete();\n            } catch (err: unknown) {\n                if (err instanceof RTSKError) {\n                    handlers.onError(err);\n                } else if ((err as any)?.name === \"AbortError\") {\n                    handlers.onError(\n                        new RTSKError({\n                            kind: \"transport\",\n                            message: \"NDJSON stream aborted\",\n                            cause: err,\n                        })\n                    );\n                } else {\n                    handlers.onError(\n                        new RTSKError({\n                            kind: \"transport\",\n                            message: \"NDJSON transport error\",\n                            cause: err,\n                        })\n                    );\n                }\n            } finally {\n                if (timeoutId !== undefined) {\n                    window.clearTimeout(timeoutId);\n                }\n                this.active = false;\n            }\n        })();\n    }\n\n    disconnect(): void {\n        if (!this.active) {\n            return;\n        }\n\n        this.active = false;\n\n        if (this.abortController) {\n            this.abortController.abort();\n            this.abortController = null;\n        }\n    }\n}\n","import { RTSKError } from \"../types\";\nimport type { Transport, TransportHandlers } from \"../types\";\n\n/**\n * Runtime configuration for the SSE transport.\n *\n * @public\n */\nexport type SseTransportConfig = {\n    /** Endpoint that exposes an SSE-compatible stream. */\n    endpoint: string;\n    /** Query string parameters appended to the endpoint URL. */\n    query?: Record<string, string | number | boolean | null | undefined>;\n    /** Whether EventSource requests include credentials. */\n    withCredentials?: boolean;\n    /** Informational retry delay; the browser ultimately controls SSE retries. */\n    retryIntervalMs?: number; // Informational only; EventSource handles its own retry\n};\n\nfunction buildUrl(endpoint: string, query?: SseTransportConfig[\"query\"]): string {\n    if (!query || Object.keys(query).length === 0) {\n        return endpoint;\n    }\n\n    const url = new URL(endpoint, window.location.origin);\n    Object.entries(query).forEach(([key, value]) => {\n        if (value === undefined || value === null) {\n            return;\n        }\n        url.searchParams.set(key, String(value));\n    });\n\n    return url.toString();\n}\n\n\n/**\n * Low-level SSE transport implementation.\n *\n * @remarks\n * This is an advanced API.\n * Most consumers should prefer {@link createStream}, which provides\n * a higher-level, protocol-agnostic interface with lifecycle management.\n *\n * This transport is exposed for advanced use cases such as custom\n * wiring, testing, or direct transport control.\n *\n * @public\n */\n\nexport class SseTransport<TRaw = unknown> implements Transport<TRaw> {\n    private readonly config: SseTransportConfig;\n    private source: EventSource | null = null;\n    private active = false;\n\n    constructor(config: SseTransportConfig) {\n        this.config = config;\n    }\n\n    connect(handlers: TransportHandlers<TRaw>): void {\n        if (this.active) {\n            return;\n        }\n\n        this.active = true;\n\n        const url = buildUrl(this.config.endpoint, this.config.query);\n\n        const source = new EventSource(url, {\n            withCredentials: Boolean(this.config.withCredentials),\n        });\n\n        this.source = source;\n\n        source.onmessage = (ev: MessageEvent) => {\n            try {\n                const raw = JSON.parse(ev.data) as TRaw;\n                handlers.onRaw(raw);\n            } catch (e) {\n                handlers.onError(\n                    new RTSKError({\n                        kind: \"protocol\",\n                        message: \"Invalid SSE message payload\",\n                        cause: e,\n                    })\n                );\n            }\n            return;\n        };\n\n        source.onerror = (event: Event) => {\n            // EventSource does not provide many details...\n            handlers.onError(\n                new RTSKError({\n                    kind: \"transport\",\n                    message: \"SSE connection error\",\n                    cause: event,\n                })\n            );\n        };\n\n        // There is no onopen here; statuses are managed by the controller above\n    }\n\n    disconnect(): void {\n        if (!this.active) {\n            return;\n        }\n\n        this.active = false;\n\n        if (this.source) {\n            this.source.close();\n            this.source = null;\n        }\n    }\n}\n","import { RTSKError } from \"../types\";\nimport type {\n    Transport,\n    TransportHandlers,\n} from \"../types\";\n\n/**\n * Runtime configuration for the WebSocket transport.\n *\n * @public\n */\nexport type WebsocketTransportConfig = {\n    /** Endpoint that accepts WebSocket connections. */\n    endpoint: string;\n    /** Query string parameters appended to the endpoint URL. */\n    query?: Record<string, string | number | boolean | null | undefined>;\n    /** WebSocket subprotocols to advertise during the handshake. */\n    protocols?: string[];\n    /** Enables automatic reconnection after unexpected closure. */\n    autoReconnect?: boolean;\n    /** Delay between reconnection attempts when {@link WebsocketTransportConfig.autoReconnect} is true. */\n    reconnectDelayMs?: number;\n};\n\nfunction buildUrl(endpoint: string, query?: WebsocketTransportConfig[\"query\"]): string {\n    if (!query || Object.keys(query).length === 0) {\n        return endpoint;\n    }\n\n    const url = new URL(endpoint, window.location.origin);\n    Object.entries(query).forEach(([key, value]) => {\n        if (value === undefined || value === null) {\n            return;\n        }\n        url.searchParams.set(key, String(value));\n    });\n\n    return url.toString();\n}\n\n/**\n * Low-level WebSocket transport implementation.\n *\n * @remarks\n * This is an advanced API.\n * Most consumers should prefer {@link createStream}, which provides\n * a higher-level, protocol-agnostic interface with lifecycle management.\n *\n * This transport is exposed for advanced use cases such as custom\n * wiring, testing, or direct transport control.\n *\n * @public\n */\n\n\nexport class WebsocketTransport<TRaw = unknown> implements Transport<TRaw> {\n    private readonly config: WebsocketTransportConfig;\n    private socket: WebSocket | null = null;\n    private handlers: TransportHandlers<TRaw> | null = null;\n    private active = false;\n    private manualClose = false;\n\n    constructor(config: WebsocketTransportConfig) {\n        this.config = config;\n    }\n\n    connect(handlers: TransportHandlers<TRaw>): void {\n        if (this.active) {\n            return;\n        }\n\n        this.handlers = handlers;\n        this.manualClose = false;\n        this.openSocket();\n    }\n\n    private openSocket(): void {\n        const url = buildUrl(this.config.endpoint, this.config.query);\n\n        const ws = this.config.protocols\n            ? new WebSocket(url, this.config.protocols)\n            : new WebSocket(url);\n\n        this.socket = ws;\n        this.active = true;\n\n        ws.onmessage = (event: MessageEvent) => {\n            if (!this.handlers) {\n                return;\n            }\n\n            try {\n                let raw: TRaw;\n                if (typeof event.data === \"string\") {\n                    raw = JSON.parse(event.data) as TRaw;\n                } else {\n                    // For now, we do not do anything fancy with binary\n                    raw = event.data as unknown as TRaw;\n                }\n                this.handlers.onRaw(raw);\n            } catch (e) {\n                this.handlers.onError(\n                    new RTSKError({\n                        kind: \"protocol\",\n                        message: \"Invalid WebSocket message payload\",\n                        cause: e,\n                    })\n                );\n            }\n        };\n\n        ws.onerror = (event: Event) => {\n            if (!this.handlers) {\n                return;\n            }\n\n            this.handlers.onError(\n                new RTSKError({\n                    kind: \"transport\",\n                    message: \"WebSocket error\",\n                    cause: event,\n                })\n            );\n        };\n\n        ws.onclose = () => {\n            this.active = false;\n\n            if (!this.handlers) {\n                return;\n            }\n\n            this.handlers.onComplete?.();\n\n            if (!this.manualClose && this.config.autoReconnect) {\n                const delay = this.config.reconnectDelayMs ?? 1000;\n                window.setTimeout(() => {\n                    // If disconnect was called in the meantime, do not reconnect\n                    if (!this.manualClose && this.handlers) {\n                        this.openSocket();\n                    }\n                }, delay);\n            }\n        };\n    }\n\n    disconnect(): void {\n        this.manualClose = true;\n        this.active = false;\n\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n            this.socket.close();\n        }\n\n        this.socket = null;\n    }\n\n    send(data: unknown): void {\n        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n            throw new RTSKError({\n                kind: \"transport\",\n                message: \"WebSocket is not open\",\n            });\n        }\n\n        if (typeof data === \"string\") {\n            this.socket.send(data);\n        } else {\n            this.socket.send(JSON.stringify(data));\n        }\n    }\n}\n","import type { Transport } from \"../types\";\nimport type { StreamDefinition } from \"../definitions\";\n\nimport { NdjsonTransport } from \"./ndjson\";\nimport { SseTransport } from \"./sse\";\nimport { WebsocketTransport } from \"./websocket\";\nimport { RTSKError } from \"../types\";\n\n/**\n * Creates a concrete transport instance that matches the provided stream definition.\n *\n * @remarks\n * This is a low-level helper used by {@link createStream} to instantiate the\n * appropriate transport for the selected protocol.\n *\n * @typeParam TRaw - Raw payload type emitted by the transport.\n * @param definition - Stream definition that determines which transport to build.\n *\n * @internal\n */\nexport function createTransportForDefinition<TRaw>(\n    definition: StreamDefinition<any, TRaw, any>\n): Transport<TRaw> {\n    const { endpoint, transportOptions } = definition;\n\n    switch (definition.mode) {\n        case \"ndjson\":\n            return new NdjsonTransport<TRaw>({\n                endpoint,\n                headers: transportOptions?.headers,\n                query: transportOptions?.query,\n                timeoutMs: transportOptions?.timeoutMs,\n            });\n\n        case \"sse\":\n            return new SseTransport<TRaw>({\n                endpoint,\n                query: transportOptions?.query,\n                withCredentials: definition.sseOptions?.withCredentials,\n                retryIntervalMs: definition.sseOptions?.retryIntervalMs,\n            });\n\n        case \"websocket\":\n            return new WebsocketTransport<TRaw>({\n                endpoint,\n                query: transportOptions?.query,\n                protocols: definition.wsOptions?.protocols,\n                autoReconnect: definition.wsOptions?.autoReconnect,\n                reconnectDelayMs: definition.wsOptions?.reconnectDelayMs,\n            });\n\n        default:\n            throw new RTSKError({\n                kind: \"internal\",\n                message: `Unsupported stream mode: ${(definition as any).mode}`,\n            });\n    }\n}\n","import type {RTSKStatus, StreamController, StreamEventHandlers, StreamSubscription, Transport,} from \"../types\";\nimport {RTSKError} from \"../types\";\nimport type {StreamDefinition} from \"../definitions\";\nimport {createTransportForDefinition} from \"../transport/factory\";\n\n/**\n * Creates a stream controller for managing client-side streaming connections.\n *\n * @remarks\n * This factory function creates a {@link StreamController} that manages the lifecycle\n * of a streaming connection and distributes events to subscribers.\n *\n * Status transitions typically include:\n * - `idle` → `connecting` → `streaming`\n * - `streaming` → `completed` (natural end)\n * - `streaming` → `error` (failure)\n * - `*` → `stopped` (manual stop)\n *\n * The controller supports multiple subscribers and notifies them of:\n * - status changes (`onStatusChange`)\n * - hydrated messages (`onNext`)\n * - errors (`onError`)\n * - completion (`onComplete`)\n *\n * @typeParam TRequest - Request payload used to initiate the stream (if applicable)\n * @typeParam TRaw - Raw payload type received from the transport layer\n * @typeParam TResponse - Hydrated payload type delivered to subscribers\n *\n * @param definition - Stream configuration defining transport mode, endpoint,\n * request mapping, and response hydration\n *\n * @returns A {@link StreamController} instance with lifecycle and subscription helpers\n *\n * @example\n * ```ts\n * const controller = createStream({\n *   mode: \"ndjson\",\n *   endpoint: \"https://api.example.com/stream\",\n *   requestMapper: (req) => req,\n *   responseHydrator: (raw) => raw,\n * });\n *\n * const sub = controller.subscribe({\n *   onStatusChange: (s) => console.log(\"Status:\", s),\n *   onNext: (v) => console.log(\"Next:\", v),\n *   onError: (e) => console.error(\"Error:\", e),\n *   onComplete: () => console.log(\"Complete\"),\n * });\n *\n * controller.start({ query: \"example\" });\n * // later...\n * controller.stop();\n * sub.unsubscribe();\n * ```\n *\n * @public\n */\nexport function createStream<TRequest, TRaw, TResponse>(\n    definition: StreamDefinition<TRequest, TRaw, TResponse>\n): StreamController<TRequest, TResponse> {\n    let status: RTSKStatus = \"idle\";\n    let active = false;\n\n    const subscribers = new Set<StreamEventHandlers<TResponse>>();\n    let transport: Transport<TRaw> | null = null;\n\n    function notifyStatus(newStatus: RTSKStatus): void {\n        if (status === newStatus) return;\n        status = newStatus;\n\n        for (const sub of subscribers) {\n            sub.onStatusChange?.(status);\n        }\n    }\n\n    function notifyNext(value: TResponse): void {\n        for (const sub of subscribers) {\n            sub.onNext?.(value);\n        }\n    }\n\n    function disconnectTransportSafely(reason: \"error\" | \"complete\" | \"stop\"): void {\n        if (!transport) return;\n\n        try {\n            transport.disconnect();\n        } catch (e) {\n            // On stop, we already report disconnect failures (see stop()).\n            // On error/complete, avoid overwriting the primary error/completion signal.\n            if (reason === \"stop\") {\n                const err = new RTSKError({\n                    kind: \"internal\",\n                    message: \"Error while disconnecting transport\",\n                    cause: e,\n                    statusBefore: status,\n                });\n\n                for (const sub of subscribers) {\n                    sub.onError?.(err);\n                }\n            }\n        } finally {\n            transport = null;\n        }\n    }\n\n    function notifyError(error: RTSKError): void {\n        // Ensure underlying resources are closed before broadcasting.\n        disconnectTransportSafely(\"error\");\n\n        notifyStatus(\"error\");\n        active = false;\n\n        for (const sub of subscribers) {\n            sub.onError?.(error);\n        }\n    }\n\n    function notifyComplete(): void {\n        // Ensure underlying resources are closed before broadcasting.\n        disconnectTransportSafely(\"complete\");\n\n        notifyStatus(\"completed\");\n        active = false;\n\n        for (const sub of subscribers) {\n            sub.onComplete?.();\n        }\n    }\n\n    function start(request?: TRequest): void {\n        if (active) {\n            // No implicit restart. Consumer controls stop/start.\n            return;\n        }\n\n        active = true;\n        notifyStatus(\"connecting\");\n\n        transport = createTransportForDefinition<TRaw>(definition);\n\n        const payload =\n            definition.requestMapper && request !== undefined\n                ? definition.requestMapper(request)\n                : request;\n\n        try {\n            transport.connect(\n                {\n                    onRaw(raw: TRaw): void {\n                        try {\n                            const hydrated = definition.responseHydrator(raw);\n\n                            // First successfully hydrated payload implies real streaming.\n                            if (status === \"connecting\") {\n                                notifyStatus(\"streaming\");\n                            }\n\n                            notifyNext(hydrated);\n                        } catch (e) {\n                            notifyError(\n                                new RTSKError({\n                                    kind: \"hydrate\",\n                                    message: \"Failed to hydrate stream payload\",\n                                    cause: e,\n                                    statusBefore: status,\n                                })\n                            );\n                        }\n                    },\n                    onError(err: RTSKError): void {\n                        notifyError(err);\n                    },\n                    onComplete(): void {\n                        notifyComplete();\n                    },\n                },\n                {\n                    payload,\n                    // Not exposing external AbortSignal for now; transports manage abort internally.\n                    signal: null,\n                }\n            );\n\n            // If connect succeeded but no data arrived yet, treat as streaming-ready.\n            if (status === \"connecting\") {\n                notifyStatus(\"streaming\");\n            }\n        } catch (e) {\n            notifyError(\n                e instanceof RTSKError\n                    ? e\n                    : new RTSKError({\n                        kind: \"internal\",\n                        message: \"Failed to start stream\",\n                        cause: e,\n                        statusBefore: status,\n                    })\n            );\n        }\n    }\n\n    function stop(): void {\n        // If inactive and not in a connecting/streaming phase, no-op.\n        if (!active && status !== \"connecting\" && status !== \"streaming\") {\n            return;\n        }\n\n        active = false;\n\n        // On stop, we *do* report disconnect failures to subscribers (internal error),\n        // but we still transition to \"stopped\" afterward.\n        disconnectTransportSafely(\"stop\");\n\n        notifyStatus(\"stopped\");\n    }\n\n    function subscribe(handlers: StreamEventHandlers<TResponse>): StreamSubscription {\n        subscribers.add(handlers);\n\n        return {\n            unsubscribe(): void {\n                subscribers.delete(handlers);\n            },\n        };\n    }\n\n    return {\n        start,\n        stop,\n        getStatus(): RTSKStatus {\n            return status;\n        },\n        isActive(): boolean {\n            return active;\n        },\n        subscribe,\n    };\n}\n"]}